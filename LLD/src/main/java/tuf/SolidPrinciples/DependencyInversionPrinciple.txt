DEPENDENCY INVERSION PRINCIPLE
---------------------------------------------


High-Level Modules: The parts of your code that contain the core logic — the brains of your application.
They make big decisions and coordinate how different features work together.
Example: CEO (makes decisions, plans strategies).

Low-Level Modules: The ones that handle the details — like talking to a database, making API calls, reading files, or providing data.
They support the high-level logic by doing the grunt work.
Example: Employees (do the actual implementation, logistics, and execution).


High-level modules should not depend on low-level modules.
Both should depend on abstractions.
Abstractions should not depend on details. Details should depend on abstractions.

In simpler words, Rather than high-level classes controlling and depending on the details of lower-level ones,
both should rely on interfaces or abstract classes. This makes your code flexible, testable, and easier to maintain.




Example : Netflix Recommendation Engine


Let's illustrate the Dependency Inversion Principle with a simple example of a Netflix recommendation engine.

Netflix uses various recommendation strategies:

Recently Added: Shows/movies recently added to the catalog
Trending Now: Based on what's currently popular
Genre-Based: What you've watched and liked before

Now let's see how Netflix might (badly) and should (correctly) implements this using the Dependency Inversion Principle.


Without DIP — Tightly Coupled Code ->

// Class implementing the recommendations based on recently added
class RecentlyAdded {
    // Method to get the recommendations
    public void getRecommendations() {
        System.out.println("Showing recently added content...");
    }
}

// Class implementing the overall Recommendation Engine
class RecommendationEngine {
    private RecentlyAdded recommender = new RecentlyAdded();

    public void recommend() {
        recommender.getRecommendations();
    }
}

Issues in the above code:
RecommendationEngine is tightly coupled to RecentlyAdded.
If we want to switch to TrendingNow or GenreBased strategies, we have to modify the engine.


With DIP — Using Abstraction ->


// Interface provided for classes to implement different recommendation strategies
interface RecommendationStrategy {
    void getRecommendations();
}

// Class implementing recommendations based on recently added
class RecentlyAdded implements RecommendationStrategy {
    public void getRecommendations() {
        System.out.println("Showing recently added content...");
    }
}

// Class implementing recommendations based on trending now
class TrendingNow implements RecommendationStrategy {
    public void getRecommendations() {
        System.out.println("Showing trending content...");
    }
}

// Class implementing recommendations based on Genre
class GenreBased implements RecommendationStrategy {
    public void getRecommendations() {
        System.out.println("Showing content based on your favorite genres...");
    }
}

// Class implementing the Recommendation Engine (High - level module)
class RecommendationEngine {
    private RecommendationStrategy strategy;

    public RecommendationEngine(RecommendationStrategy strategy) {
        this.strategy = strategy;
    }

    public void recommend() {
        strategy.getRecommendations();
    }
}

// Main driver code
class Main {
    public static void main(String[] args) {
        RecommendationStrategy strategy = new TrendingNow(); // could also be RecentlyAdded or GenreBased
        RecommendationEngine engine = new RecommendationEngine(strategy);
        engine.recommend();
    }
}


No changes required in RecommendationEngine class — just pass a new strategy.
That's the power of Dependency Inversion Principle used in designing the Recommendation Strategy.
